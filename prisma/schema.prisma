// Prisma schema for gold/abshodeh trading backend
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  TRADER
  CLIENT
}

enum UserStatus {
  ACTIVE
  BLOCKED
  PENDING_APPROVAL
}

enum InstrumentType {
  FIAT
  GOLD
  COIN
  OTHER
}

enum KycStatus {
  NONE
  PENDING
  VERIFIED
  REJECTED
}

enum KycLevel {
  NONE
  BASIC
  FULL
}

enum PolicyScopeType {
  GLOBAL
  GROUP
  USER
}

enum PolicyAction {
  WITHDRAW_IRR
  DEPOSIT_IRR
  TRADE_BUY
  TRADE_SELL
  REMITTANCE_SEND
  CUSTODY_IN
  CUSTODY_OUT
}

enum PolicyMetric {
  NOTIONAL_IRR
  WEIGHT_750_G
  COUNT
}

enum PolicyPeriod {
  DAILY
  MONTHLY
}

enum LimitReservationStatus {
  RESERVED
  CONSUMED
  RELEASED
}

enum AccountReservationStatus {
  RESERVED
  CONSUMED
  RELEASED
}

enum PolicyAuditEntityType {
  CUSTOMER_GROUP
  USER_KYC
  POLICY_RULE
}

enum InstrumentUnit {
  GRAM_750_EQ
  PIECE
  CURRENCY
}

enum TradeSide {
  BUY
  SELL
}

enum TradeStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED_BY_USER
  CANCELLED_BY_ADMIN
  SETTLED
}

enum SettlementMethod {
  WALLET
  EXTERNAL
  CASH
  PHYSICAL
  MIXED
}

enum TradeType {
  SPOT
  TOMORROW
  DAY_AFTER
}

enum QuoteSourceType {
  PROVIDER
  OVERRIDE
}

enum MarketProductType {
  CASH
  GOLD
  COIN
  FX
  OTHER
}

enum PricingOverrideMode {
  ABSOLUTE
  DELTA_BPS
  DELTA_AMOUNT
}

enum CustodyAssetType {
  GOLD
}

enum PhysicalCustodyMovementType {
  DEPOSIT
  WITHDRAWAL
}

enum PhysicalCustodyMovementStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum TxRefType {
  TRADE
  DEPOSIT
  WITHDRAW
  ADJUSTMENT
  GOLD_LOT
  // TODO: Introduce a Remittance entity/service to cover internal transfers.
  REMITTANCE
  PHYSICAL_CUSTODY_MOVEMENT
}

enum AccountTxType {
  DEPOSIT
  WITHDRAW
  TRADE_DEBIT
  TRADE_CREDIT
  ADJUSTMENT
  FEE
  REMITTANCE
  CUSTODY
}

enum DepositStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  REVERSED
}

enum WithdrawStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  REVERSED
}

enum GoldLotStatus {
  IN_VAULT
  SOLD
  WITHDRAWN
  MELTED
}

enum AttachmentEntityType {
  TRADE
  DEPOSIT
  WITHDRAW
  GOLD_LOT
  // TODO: Attachments for remittance flows will use this type once implemented.
  REMITTANCE
}

enum RemittanceGroupStatus {
  OPEN
  PARTIAL
  CLOSED
  CANCELLED
}

enum RemittanceStatus {
  PENDING // obligation created, not settled at all
  PARTIAL // partially settled by one or more settlement legs
  COMPLETED // fully settled
  CANCELLED // voided
}

enum RemittanceChannel {
  INTERNAL // default: internal bookkeeping / wallet transfer
  CASH // physical cash
  BANK_TRANSFER // standard IBAN / wire transfer
  CARD // POS/card payment
  MIXED // mixture of above, details in note or external ref
  OTHER
}

enum RemittanceGroupKind {
  TRANSFER // simple internal transfer(s)
  SETTLEMENT // explicit settlement of one or more existing remittances
  NETTING // netting/offsetting flows (we only tag it here for now)
  PASS_THROUGH // pass-through remittance, paying directly to third parties on behalf of someone
  OTHER
}

model TahesabOutbox {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  method            String
  payload           Json
  status            TahesabOutboxStatus @default(PENDING)
  retryCount        Int                 @default(0)
  lastError         String?
  nextRetryAt       DateTime            @default(now())
  correlationId     String?
  tahesabFactorCode String?

  @@index([method, correlationId])
}

enum TahesabOutboxStatus {
  PENDING
  SUCCESS
  FAILED
}

model CustomerGroup {
  id               String   @id @default(cuid())
  code             String   @unique
  name             String
  tahesabGroupName String?
  isDefault        Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  users User[]
  policyRules PolicyRule[] @relation("PolicyRuleScopeGroup")
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fullName String
  mobile   String @unique
  password String
  email    String @unique

  tahesabCustomerCode String? @unique

  role   UserRole   @default(CLIENT)
  status UserStatus @default(PENDING_APPROVAL)

  customerGroupId String?
  customerGroup   CustomerGroup? @relation(fields: [customerGroupId], references: [id])

  accounts  Account[]
  trades    Trade[]     @relation("UserTrades")
  createdTx AccountTx[] @relation("TxCreatedBy")

  // ÿ≥ŸÖÿ™ "ÿµÿßÿ≠ÿ® ÿØÿ±ÿÆŸàÿßÿ≥ÿ™"‚ÄåŸáÿß
  deposits  DepositRequest[]  @relation("UserDeposits")
  withdraws WithdrawRequest[] @relation("UserWithdraws")

  // ÿ≥ŸÖÿ™ "Ÿæÿ±ÿØÿßÿ≤ÿ¥ ⁄©ŸÜŸÜÿØŸá"‚ÄåŸáÿß (ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß)
  processedDeposits  DepositRequest[]  @relation("DepositProcessedBy")
  processedWithdraws WithdrawRequest[] @relation("WithdrawProcessedBy")

  remittancesSent         Remittance[]      @relation("RemittanceFrom")
  remittancesReceived     Remittance[]      @relation("RemittanceTo")
  remittanceGroupsCreated RemittanceGroup[]

  // üëá ÿß€åŸÜ ÿ±Ÿà ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ ÿ®ÿ±ÿß€å onBehalfOfUser
  remittancesOnBehalfOf Remittance[] @relation("RemittanceOnBehalfOf")

  // ÿ≥ŸÖÿ™ "ÿ™ÿ±€åÿØŸáÿß€å ÿ™ÿß€å€åÿØÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± (ÿßÿØŸÖ€åŸÜ)"
  approvedTrades Trade[] @relation("ApprovedTrades")

  physicalCustodyPositions PhysicalCustodyPosition[]
  physicalCustodyMovements PhysicalCustodyMovement[]

  goldLots GoldLot[]
  files    File[]    @relation("FilesUploadedBy")

  createdPriceOverrides AdminPriceOverride[] @relation("AdminPriceOverrideCreatedBy")
  revokedPriceOverrides AdminPriceOverride[] @relation("AdminPriceOverrideRevokedBy")
  settings              UserSettings?

  userKyc         UserKyc?
  policyAuditLogs PolicyAuditLog[]
  policyRules     PolicyRule[]   @relation("PolicyRuleScopeUser")
  limitUsages     LimitUsage[]

  @@index([customerGroupId])
}

model UserKyc {
  id           String    @id @default(cuid())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  userId       String    @unique
  user         User      @relation(fields: [userId], references: [id])
  status       KycStatus @default(NONE)
  level        KycLevel  @default(NONE)
  verifiedAt   DateTime?
  rejectedAt   DateTime?
  rejectReason String?
}

model Instrument {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  code String         @unique
  name String
  type InstrumentType
  unit InstrumentUnit

  accounts    Account[]
  trades      Trade[]
  prices      InstrumentPrice[]
  remittances Remittance[]
  policyRules PolicyRule[]     @relation("PolicyRuleInstrument")
  marketProducts MarketProduct[]
}

model MarketProduct {
  id             String            @id @default(cuid())
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  code           String            @unique
  displayName    String
  productType    MarketProductType
  tradeType      TradeType
  baseInstrument Instrument        @relation(fields: [baseInstrumentId], references: [id])
  baseInstrumentId String
  unitType       PolicyMetric
  groupKey       String
  sortOrder      Int               @default(0)
  isActive       Boolean           @default(true)
  metaJson       Json?

  providerMappings ProductProviderMapping[]
  priceOverrides   AdminPriceOverride[]
  policyRules      PolicyRule[]

  @@index([isActive, groupKey, sortOrder])
}

model PriceProvider {
  id                  String   @id @default(cuid())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  key                 String   @unique
  displayName         String
  baseUrl             String?
  isEnabled           Boolean  @default(true)
  supportsStreaming   Boolean  @default(false)
  defaultPollIntervalSec Int?
  authJson            Json?

  mappings ProductProviderMapping[]
}

model ProductProviderMapping {
  id           String        @id @default(cuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  product      MarketProduct @relation(fields: [productId], references: [id])
  productId    String
  provider     PriceProvider @relation(fields: [providerId], references: [id])
  providerId   String
  providerSymbol String
  priority     Int
  isEnabled    Boolean       @default(true)
  metaJson     Json?

  @@unique([productId, providerId])
  @@index([productId, isEnabled, priority])
}

model AdminPriceOverride {
  id              String             @id @default(cuid())
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  product         MarketProduct      @relation(fields: [productId], references: [id])
  productId       String
  mode            PricingOverrideMode
  buyAbsolute     Decimal?           @db.Decimal(24, 6)
  sellAbsolute    Decimal?           @db.Decimal(24, 6)
  buyDeltaBps     Int?
  sellDeltaBps    Int?
  buyDeltaAmount  Decimal?           @db.Decimal(24, 6)
  sellDeltaAmount Decimal?           @db.Decimal(24, 6)
  isActive        Boolean            @default(true)
  startsAt        DateTime           @default(now())
  expiresAt       DateTime
  reason          String
  createdByAdmin  User               @relation("AdminPriceOverrideCreatedBy", fields: [createdByAdminId], references: [id])
  createdByAdminId String
  revokedAt       DateTime?
  revokedByAdmin  User?              @relation("AdminPriceOverrideRevokedBy", fields: [revokedByAdminId], references: [id])
  revokedByAdminId String?

  @@index([productId, isActive, expiresAt])
}

model UserSettings {
  user       User     @relation(fields: [userId], references: [id])
  userId     String   @id
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  showBalances    Boolean @default(true)
  showGold        Boolean @default(true)
  showCoins       Boolean @default(true)
  showCash        Boolean @default(true)
  tradeEnabled    Boolean @default(true)
  withdrawEnabled Boolean @default(true)
  maxOpenTrades   Int?
  metaJson        Json?
}

model InstrumentPrice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  buyPrice  Decimal @db.Decimal(18, 4)
  sellPrice Decimal @db.Decimal(18, 4)
  source    String?
}

model Account {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  balance        Decimal @db.Decimal(24, 6)
  blockedBalance Decimal @default(0) @db.Decimal(24, 6)
  minBalance     Decimal @default(0) @db.Decimal(24, 6)

  transactions AccountTx[]
  reservations AccountReservation[]

  @@unique([userId, instrumentId])
}

model AccountReservation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account   Account @relation(fields: [accountId], references: [id])
  accountId String

  amount Decimal @db.Decimal(24, 6)
  refType TxRefType
  refId   String
  status  AccountReservationStatus @default(RESERVED)

  @@unique([refType, refId, accountId])
}

model AccountTx {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  account   Account @relation(fields: [accountId], references: [id])
  accountId String

  delta Decimal @db.Decimal(24, 6)

  type    AccountTxType
  refType TxRefType
  refId   String?

  createdBy   User?   @relation("TxCreatedBy", fields: [createdById], references: [id])
  createdById String?

  depositRequests  DepositRequest[]  @relation("DepositAccountTx")
  withdrawRequests WithdrawRequest[] @relation("WithdrawAccountTx")

  remittanceFrom Remittance? @relation("RemittanceFromTx")
  remittanceTo   Remittance? @relation("RemittanceToTx")

  reversalOf   AccountTx?  @relation("AccountTxReversal", fields: [reversalOfId], references: [id])
  reversalOfId String?     @unique
  reversals    AccountTx[] @relation("AccountTxReversal")

  @@index([refType, refId])
}

model Trade {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  client   User   @relation("UserTrades", fields: [clientId], references: [id])
  clientId String

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  side             TradeSide
  status           TradeStatus      @default(PENDING)
  type             TradeType        @default(SPOT)
  settlementMethod SettlementMethod

  quantity     Decimal @db.Decimal(24, 6)
  pricePerUnit Decimal @db.Decimal(24, 6)
  totalAmount  Decimal @db.Decimal(24, 6)

  idempotencyKey String?

  quoteId            String?
  executedPrice      Decimal?        @db.Decimal(24, 6)
  priceSourceType    QuoteSourceType?
  priceSourceKey     String?
  priceSourceAsOf    DateTime?
  priceSourceRefId   String?
  lockedBaseBuy      Decimal?        @db.Decimal(24, 6)
  lockedBaseSell     Decimal?        @db.Decimal(24, 6)
  lockedDisplayBuy   Decimal?        @db.Decimal(24, 6)
  lockedDisplaySell  Decimal?        @db.Decimal(24, 6)

  entryPrice       Decimal? @db.Decimal(24, 8)
  settlementPrice  Decimal? @db.Decimal(24, 8)
  settlementAmount Decimal? @db.Decimal(24, 2)
  realizedPnl      Decimal? @db.Decimal(24, 2)

  clientNote String?
  adminNote  String?

  quoteLockAudits QuoteLockAudit[]

  approvedAt   DateTime?
  approvedBy   User?     @relation("ApprovedTrades", fields: [approvedById], references: [id])
  approvedById String?

  rejectedAt   DateTime?
  rejectReason String?

  reversedAt DateTime?

  cancelledAt DateTime?

  @@unique([clientId, idempotencyKey])
}

model QuoteLockAudit {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  quoteId   String   @unique

  userId    String
  productId String
  side      TradeSide
  metric    PolicyMetric
  baseInstrumentId String
  baseInstrumentCode String

  displayBuy  Decimal? @db.Decimal(24, 6)
  displaySell Decimal? @db.Decimal(24, 6)
  baseBuy     Decimal? @db.Decimal(24, 6)
  baseSell    Decimal? @db.Decimal(24, 6)

  sourceType       QuoteSourceType?
  sourceProviderKey String?
  sourceOverrideId  String?
  asOf            DateTime
  expiresAt       DateTime
  consumedAt      DateTime?
  tradeId         String?

  trade Trade? @relation(fields: [tradeId], references: [id])
}

model PhysicalCustodyPosition {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])

  assetType CustodyAssetType @default(GOLD)

  weightGram Decimal @db.Decimal(24, 4)
  ayar       Int
  equivGram750 Decimal @default(0) @db.Decimal(24, 6)

  @@unique([userId, assetType])
  @@index([userId, assetType])
}

model PhysicalCustodyMovement {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  idempotencyKey String?

  userId String
  user   User   @relation(fields: [userId], references: [id])

  assetType CustodyAssetType @default(GOLD)

  movementType PhysicalCustodyMovementType
  status       PhysicalCustodyMovementStatus @default(PENDING)

  weightGram Decimal @db.Decimal(24, 4)
  ayar       Int
  equivGram750 Decimal? @db.Decimal(24, 6)

  userGoldAccountTxId  String?
  houseGoldAccountTxId String?

  tahesabFactorCode String?
  note              String?

  @@unique([userId, idempotencyKey])

  @@index([userId, assetType, status])
}

model DepositRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation("UserDeposits", fields: [userId], references: [id])
  userId String

  amount Decimal       @db.Decimal(24, 2)
  method String
  status DepositStatus @default(PENDING)

  refNo         String?
  note          String?
  processedAt   DateTime?
  processedBy   User?     @relation("DepositProcessedBy", fields: [processedById], references: [id])
  processedById String?

  accountTx   AccountTx? @relation("DepositAccountTx", fields: [accountTxId], references: [id])
  accountTxId String?    @unique
}

model WithdrawRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation("UserWithdraws", fields: [userId], references: [id])
  userId String

  amount Decimal        @db.Decimal(24, 2)
  status WithdrawStatus @default(PENDING)

  bankName   String?
  iban       String?
  cardNumber String?

  note          String?
  processedAt   DateTime?
  processedBy   User?     @relation("WithdrawProcessedBy", fields: [processedById], references: [id])
  processedById String?

  accountTx   AccountTx? @relation("WithdrawAccountTx", fields: [accountTxId], references: [id])
  accountTxId String?    @unique

  /// Optional idempotency key scoped to the user to make create requests safe to retry
  idempotencyKey String?

  @@unique([userId, idempotencyKey])
}

model RemittanceGroup {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The user who initiated this group (creator/initiator)
  createdBy       User   @relation(fields: [createdByUserId], references: [id])
  createdByUserId String

  /// Optional high-level note / description
  note String?

  /// Optional external reference (e.g. for reconciliation with tahesab or external systems)
  externalRef String? @unique

  /// High-level intent of this group
  kind RemittanceGroupKind @default(TRANSFER)

  /// Status of the group (OPEN, PARTIAL, CLOSED, CANCELLED)
  status RemittanceGroupStatus @default(OPEN)

  /// Optional Tahesab document ID for the group-level accounting entry
  tahesabDocId String?

  /// Legs associated with this group
  legs Remittance[]
}

model Remittance {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  idempotencyKey String?

  group   RemittanceGroup? @relation(fields: [groupId], references: [id])
  groupId String?

  fromUser   User   @relation("RemittanceFrom", fields: [fromUserId], references: [id])
  fromUserId String

  toUser   User   @relation("RemittanceTo", fields: [toUserId], references: [id])
  toUserId String

  /// Optional "on behalf of" user: the party whose obligation is being settled by this leg
  onBehalfOfUser   User?   @relation("RemittanceOnBehalfOf", fields: [onBehalfOfUserId], references: [id])
  onBehalfOfUserId String?

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  amount Decimal @db.Decimal(24, 6)
  note   String?

  /// How the payment was made in the real world
  channel            RemittanceChannel @default(INTERNAL)
  iban               String?
  cardLast4          String? // last 4 digits of card, if applicable
  externalPaymentRef String? // bank ref number, POS trace, etc.

  /// Status of this leg: PENDING until funds move, COMPLETED after both AccountTx are created,
  /// CANCELLED if the leg is voided.
  status RemittanceStatus @default(PENDING)

  /// Optional Tahesab document ID for the accounting entry of this leg
  tahesabDocId String?

  fromAccountTx   AccountTx? @relation("RemittanceFromTx", fields: [fromAccountTxId], references: [id])
  fromAccountTxId String?    @unique

  toAccountTx   AccountTx? @relation("RemittanceToTx", fields: [toAccountTxId], references: [id])
  toAccountTxId String?    @unique

  settlementsAsLeg    RemittanceSettlementLink[] @relation("SettlementLegLinks")
  settlementsAsSource RemittanceSettlementLink[] @relation("SettlementSourceLinks")

  @@unique([fromUserId, idempotencyKey])
}

model RemittanceSettlementLink {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The executing leg (a remittance that carries money)
  leg   Remittance @relation("SettlementLegLinks", fields: [legId], references: [id])
  legId String

  /// The source remittance that this leg settles (fully or partially)
  sourceRemittance   Remittance @relation("SettlementSourceLinks", fields: [sourceRemittanceId], references: [id])
  sourceRemittanceId String

  /// How much of the leg amount is allocated to this particular source remittance
  amount Decimal @db.Decimal(24, 6)

  note String?

  @@index([legId])
  @@index([sourceRemittanceId])
}

model GoldLot {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  grossWeight  Decimal @db.Decimal(24, 6)
  karat        Int
  equivGram750 Decimal @db.Decimal(24, 6)

  status GoldLotStatus @default(IN_VAULT)

  note String?
}

model File {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  uploadedBy   User   @relation("FilesUploadedBy", fields: [uploadedById], references: [id])
  uploadedById String

  storageKey String
  fileName   String
  mimeType   String
  sizeBytes  Int

  label String?

  attachments Attachment[]
}

model Attachment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  file   File   @relation(fields: [fileId], references: [id])
  fileId String

  entityType AttachmentEntityType
  entityId   String

  purpose String?
}

model PolicyRule {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  scopeType   PolicyScopeType
  scopeUserId String?
  scopeGroupId String?
  action      PolicyAction
  metric      PolicyMetric
  period      PolicyPeriod
  limit       Decimal @db.Decimal(24, 6)
  minKycLevel KycLevel @default(NONE)
  instrumentId String?
  instrumentType InstrumentType?
  productId     String?
  enabled     Boolean @default(true)
  priority    Int     @default(100)
  note        String?

  scopeUser  User?          @relation("PolicyRuleScopeUser", fields: [scopeUserId], references: [id])
  scopeGroup CustomerGroup? @relation("PolicyRuleScopeGroup", fields: [scopeGroupId], references: [id])
  instrument Instrument?    @relation("PolicyRuleInstrument", fields: [instrumentId], references: [id])
  product    MarketProduct? @relation(fields: [productId], references: [id])

  @@index([scopeType, scopeUserId, scopeGroupId])
  @@index([scopeType, scopeGroupId, scopeUserId, productId])
  @@index([action, metric, period])
  @@index([instrumentId, instrumentType])
  @@index([productId, action, metric, period])
}

model LimitUsage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId  String
  user    User   @relation(fields: [userId], references: [id])
  action  PolicyAction
  metric  PolicyMetric
  period  PolicyPeriod
  periodKey String
  instrumentKey String  @default("ALL")
  usedAmount     Decimal @default(0) @db.Decimal(24, 6)
  reservedAmount Decimal @default(0) @db.Decimal(24, 6)

  reservations LimitReservation[]

  @@unique([userId, action, metric, period, periodKey, instrumentKey])
}

model LimitReservation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  usageId String
  usage   LimitUsage @relation(fields: [usageId], references: [id])
  amount  Decimal @db.Decimal(24, 6)
  refType String
  refId   String
  status  LimitReservationStatus @default(RESERVED)

  @@unique([refType, refId, usageId])
}

model PolicyAuditLog {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  entityType PolicyAuditEntityType
  entityId   String
  actorId    String?
  actor      User?    @relation(fields: [actorId], references: [id])
  beforeJson Json?
  afterJson  Json?
  reason     String?

  @@index([entityType, entityId])
}
