// Prisma schema for gold/abshodeh trading backend
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  TRADER
  CLIENT
}

enum UserStatus {
  ACTIVE
  BLOCKED
  PENDING_APPROVAL
}

enum InstrumentType {
  FIAT
  GOLD
  COIN
  OTHER
}

enum InstrumentUnit {
  GRAM_750_EQ
  PIECE
  CURRENCY
}

enum TradeSide {
  BUY
  SELL
}

enum TradeStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED_BY_USER
  CANCELLED_BY_ADMIN
  SETTLED
}

enum SettlementMethod {
  WALLET
  EXTERNAL
  CASH
  PHYSICAL
  MIXED
}

enum TradeType {
  SPOT
  TOMORROW
  DAY_AFTER
}

enum CustodyAssetType {
  GOLD
}

enum PhysicalCustodyMovementType {
  DEPOSIT
  WITHDRAWAL
}

enum PhysicalCustodyMovementStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum TxRefType {
  TRADE
  DEPOSIT
  WITHDRAW
  ADJUSTMENT
  GOLD_LOT
  // TODO: Introduce a Remittance entity/service to cover internal transfers.
  REMITTANCE
  PHYSICAL_CUSTODY_MOVEMENT
}

enum AccountTxType {
  DEPOSIT
  WITHDRAW
  TRADE_DEBIT
  TRADE_CREDIT
  ADJUSTMENT
  FEE
  REMITTANCE
  CUSTODY
}

enum DepositStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  REVERSED
}

enum WithdrawStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  REVERSED
}

enum GoldLotStatus {
  IN_VAULT
  SOLD
  WITHDRAWN
  MELTED
}

enum AttachmentEntityType {
  TRADE
  DEPOSIT
  WITHDRAW
  GOLD_LOT
  // TODO: Attachments for remittance flows will use this type once implemented.
  REMITTANCE
}

enum RemittanceGroupStatus {
  OPEN
  PARTIAL
  CLOSED
  CANCELLED
}

enum RemittanceStatus {
  PENDING // obligation created, not settled at all
  PARTIAL // partially settled by one or more settlement legs
  COMPLETED // fully settled
  CANCELLED // voided
}

enum RemittanceChannel {
  INTERNAL // default: internal bookkeeping / wallet transfer
  CASH // physical cash
  BANK_TRANSFER // standard IBAN / wire transfer
  CARD // POS/card payment
  MIXED // mixture of above, details in note or external ref
  OTHER
}

enum RemittanceGroupKind {
  TRANSFER // simple internal transfer(s)
  SETTLEMENT // explicit settlement of one or more existing remittances
  NETTING // netting/offsetting flows (we only tag it here for now)
  PASS_THROUGH // pass-through remittance, paying directly to third parties on behalf of someone
  OTHER
}

model TahesabOutbox {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  method            String
  payload           Json
  status            TahesabOutboxStatus @default(PENDING)
  retryCount        Int                 @default(0)
  lastError         String?
  nextRetryAt       DateTime            @default(now())
  correlationId     String?
  tahesabFactorCode String?

  @@index([method, correlationId])
}

enum TahesabOutboxStatus {
  PENDING
  SUCCESS
  FAILED
}

model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fullName String
  mobile   String @unique
  password String
  email    String @unique

  tahesabCustomerCode String? @unique

  role   UserRole   @default(CLIENT)
  status UserStatus @default(PENDING_APPROVAL)

  accounts  Account[]
  trades    Trade[]     @relation("UserTrades")
  createdTx AccountTx[] @relation("TxCreatedBy")

  // ÿ≥ŸÖÿ™ "ÿµÿßÿ≠ÿ® ÿØÿ±ÿÆŸàÿßÿ≥ÿ™"‚ÄåŸáÿß
  deposits  DepositRequest[]  @relation("UserDeposits")
  withdraws WithdrawRequest[] @relation("UserWithdraws")

  // ÿ≥ŸÖÿ™ "Ÿæÿ±ÿØÿßÿ≤ÿ¥ ⁄©ŸÜŸÜÿØŸá"‚ÄåŸáÿß (ÿßÿØŸÖ€åŸÜ‚ÄåŸáÿß)
  processedDeposits  DepositRequest[]  @relation("DepositProcessedBy")
  processedWithdraws WithdrawRequest[] @relation("WithdrawProcessedBy")

  remittancesSent         Remittance[]      @relation("RemittanceFrom")
  remittancesReceived     Remittance[]      @relation("RemittanceTo")
  remittanceGroupsCreated RemittanceGroup[]

  // üëá ÿß€åŸÜ ÿ±Ÿà ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜ ÿ®ÿ±ÿß€å onBehalfOfUser
  remittancesOnBehalfOf Remittance[] @relation("RemittanceOnBehalfOf")

  // ÿ≥ŸÖÿ™ "ÿ™ÿ±€åÿØŸáÿß€å ÿ™ÿß€å€åÿØÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± (ÿßÿØŸÖ€åŸÜ)"
  approvedTrades Trade[] @relation("ApprovedTrades")

  physicalCustodyPositions PhysicalCustodyPosition[]
  physicalCustodyMovements PhysicalCustodyMovement[]

  goldLots GoldLot[]
  files    File[]    @relation("FilesUploadedBy")
}

model Instrument {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  code String         @unique
  name String
  type InstrumentType
  unit InstrumentUnit

  accounts    Account[]
  trades      Trade[]
  prices      InstrumentPrice[]
  remittances Remittance[]
}

model InstrumentPrice {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  buyPrice  Decimal @db.Decimal(18, 4)
  sellPrice Decimal @db.Decimal(18, 4)
  source    String?
}

model Account {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  balance        Decimal @db.Decimal(24, 6)
  blockedBalance Decimal @default(0) @db.Decimal(24, 6)
  minBalance     Decimal @default(0) @db.Decimal(24, 6)

  transactions AccountTx[]

  @@unique([userId, instrumentId])
}

model AccountTx {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  account   Account @relation(fields: [accountId], references: [id])
  accountId String

  delta Decimal @db.Decimal(24, 6)

  type    AccountTxType
  refType TxRefType
  refId   String?

  createdBy   User?   @relation("TxCreatedBy", fields: [createdById], references: [id])
  createdById String?

  depositRequests  DepositRequest[]  @relation("DepositAccountTx")
  withdrawRequests WithdrawRequest[] @relation("WithdrawAccountTx")

  remittanceFrom Remittance? @relation("RemittanceFromTx")
  remittanceTo   Remittance? @relation("RemittanceToTx")

  reversalOf   AccountTx?  @relation("AccountTxReversal", fields: [reversalOfId], references: [id])
  reversalOfId String?     @unique
  reversals    AccountTx[] @relation("AccountTxReversal")

  @@index([refType, refId])
}

model Trade {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  client   User   @relation("UserTrades", fields: [clientId], references: [id])
  clientId String

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  side             TradeSide
  status           TradeStatus      @default(PENDING)
  type             TradeType        @default(SPOT)
  settlementMethod SettlementMethod

  quantity     Decimal @db.Decimal(24, 6)
  pricePerUnit Decimal @db.Decimal(24, 6)
  totalAmount  Decimal @db.Decimal(24, 6)

  entryPrice       Decimal? @db.Decimal(24, 8)
  settlementPrice  Decimal? @db.Decimal(24, 8)
  settlementAmount Decimal? @db.Decimal(24, 2)
  realizedPnl      Decimal? @db.Decimal(24, 2)

  clientNote String?
  adminNote  String?

  approvedAt   DateTime?
  approvedBy   User?     @relation("ApprovedTrades", fields: [approvedById], references: [id])
  approvedById String?

  rejectedAt   DateTime?
  rejectReason String?

  reversedAt DateTime?
}

model PhysicalCustodyPosition {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])

  assetType CustodyAssetType @default(GOLD)

  weightGram Decimal @db.Decimal(24, 4)
  ayar       Int
  equivGram750 Decimal @default(0) @db.Decimal(24, 6)

  @@unique([userId, assetType])
  @@index([userId, assetType])
}

model PhysicalCustodyMovement {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])

  assetType CustodyAssetType @default(GOLD)

  movementType PhysicalCustodyMovementType
  status       PhysicalCustodyMovementStatus @default(PENDING)

  weightGram Decimal @db.Decimal(24, 4)
  ayar       Int
  equivGram750 Decimal? @db.Decimal(24, 6)

  userGoldAccountTxId  String?
  houseGoldAccountTxId String?

  tahesabFactorCode String?
  note              String?

  @@index([userId, assetType, status])
}

model DepositRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation("UserDeposits", fields: [userId], references: [id])
  userId String

  amount Decimal       @db.Decimal(24, 2)
  method String
  status DepositStatus @default(PENDING)

  refNo         String?
  note          String?
  processedAt   DateTime?
  processedBy   User?     @relation("DepositProcessedBy", fields: [processedById], references: [id])
  processedById String?

  accountTx   AccountTx? @relation("DepositAccountTx", fields: [accountTxId], references: [id])
  accountTxId String?    @unique
}

model WithdrawRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation("UserWithdraws", fields: [userId], references: [id])
  userId String

  amount Decimal        @db.Decimal(24, 2)
  status WithdrawStatus @default(PENDING)

  bankName   String?
  iban       String?
  cardNumber String?

  note          String?
  processedAt   DateTime?
  processedBy   User?     @relation("WithdrawProcessedBy", fields: [processedById], references: [id])
  processedById String?

  accountTx   AccountTx? @relation("WithdrawAccountTx", fields: [accountTxId], references: [id])
  accountTxId String?    @unique
}

model RemittanceGroup {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The user who initiated this group (creator/initiator)
  createdBy       User   @relation(fields: [createdByUserId], references: [id])
  createdByUserId String

  /// Optional high-level note / description
  note String?

  /// Optional external reference (e.g. for reconciliation with tahesab or external systems)
  externalRef String? @unique

  /// High-level intent of this group
  kind RemittanceGroupKind @default(TRANSFER)

  /// Status of the group (OPEN, PARTIAL, CLOSED, CANCELLED)
  status RemittanceGroupStatus @default(OPEN)

  /// Optional Tahesab document ID for the group-level accounting entry
  tahesabDocId String?

  /// Legs associated with this group
  legs Remittance[]
}

model Remittance {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  group   RemittanceGroup? @relation(fields: [groupId], references: [id])
  groupId String?

  fromUser   User   @relation("RemittanceFrom", fields: [fromUserId], references: [id])
  fromUserId String

  toUser   User   @relation("RemittanceTo", fields: [toUserId], references: [id])
  toUserId String

  /// Optional "on behalf of" user: the party whose obligation is being settled by this leg
  onBehalfOfUser   User?   @relation("RemittanceOnBehalfOf", fields: [onBehalfOfUserId], references: [id])
  onBehalfOfUserId String?

  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  instrumentId String

  amount Decimal @db.Decimal(24, 6)
  note   String?

  /// How the payment was made in the real world
  channel            RemittanceChannel @default(INTERNAL)
  iban               String?
  cardLast4          String? // last 4 digits of card, if applicable
  externalPaymentRef String? // bank ref number, POS trace, etc.

  /// Status of this leg: PENDING until funds move, COMPLETED after both AccountTx are created,
  /// CANCELLED if the leg is voided.
  status RemittanceStatus @default(PENDING)

  /// Optional Tahesab document ID for the accounting entry of this leg
  tahesabDocId String?

  fromAccountTx   AccountTx? @relation("RemittanceFromTx", fields: [fromAccountTxId], references: [id])
  fromAccountTxId String?    @unique

  toAccountTx   AccountTx? @relation("RemittanceToTx", fields: [toAccountTxId], references: [id])
  toAccountTxId String?    @unique

  settlementsAsLeg    RemittanceSettlementLink[] @relation("SettlementLegLinks")
  settlementsAsSource RemittanceSettlementLink[] @relation("SettlementSourceLinks")
}

model RemittanceSettlementLink {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The executing leg (a remittance that carries money)
  leg   Remittance @relation("SettlementLegLinks", fields: [legId], references: [id])
  legId String

  /// The source remittance that this leg settles (fully or partially)
  sourceRemittance   Remittance @relation("SettlementSourceLinks", fields: [sourceRemittanceId], references: [id])
  sourceRemittanceId String

  /// How much of the leg amount is allocated to this particular source remittance
  amount Decimal @db.Decimal(24, 6)

  note String?

  @@index([legId])
  @@index([sourceRemittanceId])
}

model GoldLot {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  grossWeight  Decimal @db.Decimal(24, 6)
  karat        Int
  equivGram750 Decimal @db.Decimal(24, 6)

  status GoldLotStatus @default(IN_VAULT)

  note String?
}

model File {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  uploadedBy   User   @relation("FilesUploadedBy", fields: [uploadedById], references: [id])
  uploadedById String

  storageKey String
  fileName   String
  mimeType   String
  sizeBytes  Int

  label String?

  attachments Attachment[]
}

model Attachment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  file   File   @relation(fields: [fileId], references: [id])
  fileId String

  entityType AttachmentEntityType
  entityId   String

  purpose String?
}
